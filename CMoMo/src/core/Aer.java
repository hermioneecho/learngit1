/**
 * 
 */
package core;

import java.util.ArrayList;
import dataStructure.Token;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import bytecode.DebugBytecode;
import cvm.DebugInfo;
import dataStructure.ANode;
import dataStructure.SNode;
import bytecode.Kinds;
/**
 * @author daos
 * Aer is A-er, is ANode-er, who deal with ANode and do such A things:
 * @ ANode Tree(Attribute Tree) fulfillment
 * @ Arise semantics errors
 * @ Assembly
 */
public class Aer {
	
	/**
	 * @ global environment. 
	 * @ environment means where the program is running on, where their methods and variables comes from.
	 * @ more information can be saw in WangYin's famous article : How to write an interpreter 
	 * @ To detect the re-declaration problem I use Map for convenience
	 */
	private static Map<String,ANode> globalEnv;
	
	
	/**
	 * local environment. local variables for each function
	 */
	private static List<HashMap<String/*local variable name*/, ANode/* variable's attribute*/>> localEnvs;
	
	private static List<String> functionNames;
	
	/**
	 * indicate which local environment it is now
	 * -1 if only global environment
	 */
	private static int currentEnv;
	
	private static List<String> strings;
	
	/**
	 * @ the name should be doubles but historically it is float that is to be put into the stack.
	 * @ an ArrayList for the real_literal
	 */
	private static List<Double> floats;
	
	/**
	 * root of ANode tree
	 */
	private static ANode A;
	
	private DebugInfo out;
	
	/**
	 * @param id
	 * @return Anode with the Symbol name id, null if no
	 */
	private ANode getVariable(String id)
	{
		// search the environment and return the ANode
		// variable could be anything that has a ID
		ANode result = null;
		//search local environment
		if(currentEnv != -1)
		{
			result = localEnvs.get(currentEnv).get(id);
		}
		if(result == null)
			result = globalEnv.get(id);
		if(result.getTag().equals("Bad Node"))
			return null;
		return result;
	}
	
	private boolean isLocal(String symbol)
	{
		return localEnvs.get(currentEnv).get(symbol)!=null;
	}
	
	/**
	 * @param rnode
	 * @return anode being referenced by rnode(rnode is a "left_value", with the same identifier)
	 */
	private ANode getVariableByNode(ANode rnode)
	{
		return getVariable((String)(((ArrayList<Object>)rnode.getContents()).get(1)));
	}
	 

	public Aer(SNode S) {
		super();
		A = ANode.convert(S);
		out = new DebugInfo(this);
		globalEnv = new HashMap<String,ANode>();
		localEnvs = new ArrayList<HashMap<String,ANode>>();
		strings = new ArrayList<String>();
		floats = new ArrayList<Double>();
		functionNames = new ArrayList<String>();
		
		//add the main fuction
		currentEnv = 0;
		functionNames.add("main");
		
	}
	
	public void fillAST()
	{
		if(setGlobalEnv())
			System.out.println("fill AST successfully!");
		else
		System.out.println("fail to fill AST");
		
		//show the globalEnv

			String result = "GlobalEnv: \n";
			java.util.Iterator<Entry<String, ANode>> attrI = globalEnv.entrySet().iterator();
			Entry<String, ANode> cur = null;
			
			while(attrI.hasNext())
			{
				cur = attrI.next();
				result+=cur.getKey()+":"+ cur.getValue().toString()+"\n";
			}
			System.out.println(result);
	}
	
	public ANode getRoot()
	{
		return A;
	}
	
	/**
	 * @param symbol
	 * @param node£¬ the node is named as symbol
	 * if the symbol exists already then do nothing
	 */
	private static boolean addToGlobal(String symbol, ANode node)
	{
		if(!globalEnv.containsKey(symbol))
		{
			globalEnv.put(symbol, node);
			return true;
		}
		node.goodNodeComeBad("the symbol(identifier) already exists!");
		return false;
	}
	
	/**
	 * @return success or not
	 * what is environment is explained in the declaration of globalEnv
	 */
	private boolean setGlobalEnv()
	{
		currentEnv = -1;
		Enumeration<ANode> round = A.children();
		ANode tmp = null;
		int variableCount = 0;
		int functionCount = 0;
		String symbol = null;
		
		while(round.hasMoreElements())
		{
			tmp = round.nextElement();
			if(tmp.getTag().equals("function_definition"))
			{
				symbol = this.AFunctionDeclaration(tmp);
				if(symbol == null)
					return false;
				if(addToGlobal(symbol, tmp))
				{
					functionCount++;
				}
			}
			else
			{
				if(tmp.getTag().equals("declaration"))
				{
					symbol = this.ADeclaration(tmp);
					if(symbol == null)
						return false;
					if(addToGlobal(symbol, tmp))
					{
						variableCount++;
					}
				}
				else
				{
					//definition, needs more attentions
					symbol = this.ADefinition(tmp);
					if(symbol == null)
						return false;
					if(addToGlobal(symbol, tmp))
					{
						variableCount++;
					}
				}
			}
		}
		
		A.addAttribute("Function Count", functionCount);
		A.addAttribute("Global Variable Count", variableCount);		
		return true;
	}
	
	/**
	 * @param id, the node that generated by mkid in syntaxer...
	 * @return symbol of id node
	 */
	private static String getSymbolFromMkid(ANode id)
	{
		return (String)((Token)id.getContents()).getWord();
	}
	
	private String AFunctionDeclaration(ANode a)
	{
		ANode dt = a.getChildAt(0);
		ANode id = a.getChildAt(1);
		ANode pl = a.getChildAt(2);
		
		a.addAttribute("Data Type:",(String)dt.getContents());
		a.addAttribute("Symbol", getSymbolFromMkid(id));
		int plsize = pl.getChildCount();
		a.addAttribute("Parameter Size", plsize);
		
		Enumeration<ANode> prms = pl.children();
		ANode pr = null;
		String prDT = null;
		String prID = null;
		List<String> prSymbols = new ArrayList<String>();
		List<String> prTypes = new ArrayList<String>(); 
		while(prms.hasMoreElements())
		{
			pr = prms.nextElement();
			prDT = (String) pr.getChildAt(0).getContents();
			prID = (String) getSymbolFromMkid(pr.getChildAt(1));
			prSymbols.add(prID);
			prTypes.add(prDT);
		}
		a.addAttribute("Parameter Types", prTypes);
		a.addAttribute("Parameter Symbols", prSymbols);
		
		return getSymbolFromMkid(id);
	}
	
	
	private String ADeclaration(ANode a)
	{
		ANode dt = a.getChildAt(0);
		ANode lv = a.getChildAt(1);
		ArrayList<Object> contents = (ArrayList<Object>) lv.getContents();
		boolean isPointer = (boolean) contents.get(0);
		String ID = (String) contents.get(1);
		int arraysize = (int) contents.get(2);
		a.addAttribute("Symbol", ID);
		a.addAttribute("Data Type", (String)dt.getContents());
		if(!isPointer)
		    a.addAttribute("Pointer", false);
		else
			a.addAttribute("Pointer", true);
		if(arraysize > 0)
			a.addAttribute("Array Size", arraysize);
		else
			a.addAttribute("Array Size", (int)0);
		return ID;
	}
	
	/**
	 * @param a
	 * @return name of the global defined variable only, not local one
	 * tag "initialized value" to Anode a, to be used by the Loader
	 */
	private String ADefinition(ANode a)
	{
		String symbol = this.ADeclaration(a);
		ANode rightValue = a.getChildAt(2);
		int arraysize = 0;
		//write a function to compare the two ANodes
		
		//is Array?
		if((arraysize=(int)a.getAttribute("Array Size"))>0)
		{
			if(rightValue.getTag().equals("array_literal_node"))
			{
				String arrayType = null;
				String entryTpye = null;
				ANode entry = null;
				List<Object> valueArray = new ArrayList<Object>();
				// at least one element in the array
				if(rightValue.getChildAt(0).getTag().equals("integer_literal"))
				{
					arrayType = "int";
					entryTpye = "integer_literal";
				}
				else
				{
					arrayType = "real";
					entryTpye = "integer_literal";
				}
				Enumeration<ANode> entries = rightValue.children();
				while(entries.hasMoreElements())
				{
					if((entry=entries.nextElement()).getTag().equals(entryTpye))
					{
						valueArray.add(entry.getContents());
					}
					else
					{
						a.goodNodeComeBad("Unmatched Array Entry Type");
						return null;
					}
				}
				rightValue.addAttribute("Array Values", valueArray);
				if(arraysize != valueArray.size())
				{
					a.goodNodeComeBad("Unmatched Array Entries Numbers");
					return null;
				}
				else
					a.addAttribute("Array Values",valueArray);
				return symbol;
			}
		}
			
		//is pointer?
		// &array[1] is forbidden
		else if((boolean)a.getAttribute("Pointer"))
		{
			if(rightValue.getTag().equals("address_of_identifier"))
			{
				String pointTo = (String)rightValue.getContents();
				if(compare(getVariable(pointTo),a,"Data Type"))
				{
					a.addAttribute("Point To", pointTo);
					return symbol;
				}
				a.goodNodeComeBad("Unmatched Type");
				return null;
			}
			else
			{
				ANode id = getVariableByNode(rightValue);	
				if(id!=null)
				{
					a.goodNodeComeBad("use unexist symbol(identifier");
					return null;
				}
				if(compare(id,a,"Data Type") && (boolean)id.getAttribute("Pointer"))
				{
					a.addAttribute("Point To", id.getAttribute("Point To"));
					rightValue.setTag("right_value");
					return symbol;
				}
				a.goodNodeComeBad("Unmatched Type");
				return null;
			}
		}
		
		//is value assignment. a is not pointer or array
		else {
			// if dereference a pointer, assign the "Point To" to it
			// if dereference an array, extract and assign the value to it
			// if identifier, test data type and initialize data
			// if literal, just do it, needn't to push double to float, because just assign
			int index;
			
			// assign a literal
			if(rightValue.getTag().equals("integer_literal"))
			{
				if(a.getAttribute("Data Type").equals("int"))
				{
					a.addAttribute("Initial Value", (int)rightValue.getContents());
					return symbol;
				}
				else
				{
					a.goodNodeComeBad("Unmatched Type");
					return null;
				}
			}
			else if(rightValue.getTag().equals("real_literal"))
			{
				if(a.getAttribute("Data Type").equals("real"))
				{
					a.addAttribute("Initial Value", (double)rightValue.getContents());
					return symbol;
				}
				else
				{
					a.goodNodeComeBad("Unmatched Type");
					return null;
				}
			}
			
			// assign a "left value"
			ANode id = getVariableByNode(rightValue);
			if(id==null)
			{
				a.goodNodeComeBad("use unexist symbol");
			}
			if(compare(id, a, "Data Type")==false)
			{
				a.goodNodeComeBad("Unmatched Type");
				return null;
			}
			if((boolean)id.getAttribute("Pointer"))
			{
				rightValue.setTag("right_value");
				a.addAttribute("Dereference", (String)id.getAttribute("Point To"));
				return symbol;
			}
			else if((index=(int)((ArrayList<Object>)rightValue.getContents()).get(2))>0)
			{
				if(index >= (int)id.getAttribute("Array Size"))
				{
					a.goodNodeComeBad("Out of Range");
					return null;
				}
				rightValue.setTag("right_value");
				// get the literal 
				Object value = ((ArrayList<Object>)id.getAttribute("Array Values")).get(index);
				a.addAttribute("Initial Value", value);
				return symbol;
			}
			else
			{
				rightValue.setTag("right_value");
				a.addAttribute("Dereference", (String)id.getAttribute("Symbol"));
				return symbol;
			}
		}						
	
		return null;
	}
	
	
	private static boolean compare(ANode a, ANode b, String tag)
	{
		return a.getAttribute(tag).equals(b.getAttribute(tag));
	}
	
	/*
	 * it is time to cope with the local environment, the task is only focus on:
	 * 1. use the unmatched variable, the type check
	 * 2. use the unexist variable
	 * 3. generate bytecode...
	 * 4. done by the following function Compile
	 */
	
	/*
	 * How to:
	 * 1. Walk through and the types of operation are limited
	 * 2. for Arithmetic operations, finish the unit_expression first(using the stack bytecode) the backup and just generate code
	 * 3. for IO, just generate it
	 * 4. for function, just generate it
	 * 5. for jump, fill back. keep some local number in the stack and when comes back we fill
	 * 6. xxx, with a stack operation, just generate it 
	 */
	
	private void Assembly(){
		globalEnv.forEach((string,anode)->
		{
			if(anode.getTag().equals("function_definition"))
			{
				Enumeration<ANode> e = anode.children();
				ANode c;
				String symbol;
				currentEnv = 1; //currentEnv == 0 if the function is main()
				while(e.hasMoreElements())
				{
					/*
					 * add the name to function name
					 * 
					 */
					if((c=e.nextElement()).getTag().equals("declaration"))
					{
						// if null, the code is set as bad automatically
						if((symbol = this.ADeclaration(c))!=null)
						{
							localEnvs.get(currentEnv).put(symbol, c);
						}
						
					}
					else if(c.getTag().equals("definition"))
					{
						// if null, the code is set as bad automatically
						if((symbol = this.ADeclaration(c))!=null)
						{
							localEnvs.get(currentEnv).put(symbol, c);
						}					
					}
					else if(c.getTag().equals("assignment"))
					{
						ANode left = c.getChildAt(0);
						symbol=getSymbolFromLeftValue(left);
						ADeclaration(left);
						ANode d = getVariable(symbol);
						ANode right = c.getChildAt(1);
						AExpression(right);
						
						//check left
						if(d == null)
						{
							c.goodNodeComeBad("Unexisted Symbol");
							return;
						}
						
						//check right
						if(isBad(right))
						{
							c.goodNodeComeBad("Illegal Expression");
							return;
						}
						
						//check type
						if(compare(d,right,"Data Type"))
						{
							//pointer
							if((boolean)d.getAttribute("Pointer") == true && right.getTag().equals("address_of_identifier"))
								add(c, new DebugBytecode(Kinds.vload,0,symbol));
							//value
							if((boolean)d.getAttribute("Pointer") == false && !right.getTag().equals("address_of_identifier"))
							{
								//array
								if((int)d.getAttribute("Array Size")>0)
								{
									add(c, new DebugBytecode(Kinds.debugBytecodeGetArray,(int)left.getAttribute("Array Size"),symbol));
								}
								else
								{
									add(c, new DebugBytecode(Kinds.vload,0,symbol));
								}
							}
						}
					}
				}
				//else if(other cases)... TODO
				currentEnv++;
			}
			//check the main function : return int and no parameter
		});
	}
	
	/**
	 * @param a expression_unit node
	 * @return a stack operation bytecode with debug information
	 */
	

	
	/////stop here
	private void AUnit(ANode a)
	{
		if(a.getTag().equals("integer_literal"))
		{
			addDataType(a, "int");
			add(a,new DebugBytecode(Kinds.push,(int)a.getContents()));
		}
		else if(a.getTag().equals("real_literal"))
		{
			addDataType(a, "real");
			floats.add((double)a.getContents());
			add(a,new DebugBytecode(Kinds.fpush,floats.size()-1));
		}
		else if(a.getTag().equals("function_call"))
		{
			//set type
			String returnType = getDataType(getSymbolFromMkid(a.getChildAt(0)));
			if(returnType == null)
			{
				a.goodNodeComeBad("Unexisted Symbol");
				return;
			}
			addDataType(a,returnType);
			//push the arguments to the stack
			ANode al = a.getChildAt(1);
			Enumeration<ANode> ale = al.children();
			while(ale.hasMoreElements())
			{
				AExpression(ale.nextElement());
			}
			//then invoke
			add(a,new DebugBytecode(Kinds.invoke,(String)a.getChildAt(0).getContents()));
		}
		else if(a.getTag().equals("left_value"))
		{
			ArrayList<Object> contents = (ArrayList<Object>) a.getContents();
			boolean isPointer = (boolean) contents.get(0);
			String symbol = (String) contents.get(1);
			int arraysize = (int) contents.get(2);
			
			//check and set the type
			ANode d = getVariable(symbol);
			if(d==null)
			{
				a.goodNodeComeBad("Unexisted Symbol");
				return;
			}
			a.addAttribute("Data Type", getDataType(d));			
			
			//check array, dereference, identifier
			if(arraysize>0)
			{
				if((int)d.getAttribute("Array Size")==0)
				{
					a.goodNodeComeBad("Unmatched Type");
					return;
				}
				add(a,new DebugBytecode(Kinds.debugBytecodeGetArray,arraysize,(String)symbol));					
				a.addAttribute("Data Type", "int");
			}
			else if(isPointer)
			{
				if((boolean)d.getAttribute("Pointer")==false)
				{
					a.goodNodeComeBad("Unmatched Type");
					return;
				}
				add(a,new DebugBytecode(Kinds.aload,symbol));
			}
			else if(arraysize==0 && isPointer==false)
			{
				if((boolean)d.getAttribute("Pointer")&&(int)d.getAttribute("Array Size")>0)
				{
					a.goodNodeComeBad("Unmatched Type");
					return;
				}
				add(a,new DebugBytecode(Kinds.vload,symbol));
			}
			else
			{
				a.goodNodeComeBad("Unmatched Type");
				return;
			}
		}
		else if(a.getTag().equals("address_of_identifier"))
		{
			//check and add
			ANode d = getVariable((String)a.getContents());
			if(d==null)
			{
				a.goodNodeComeBad("Unexisted Symbol");
				return;
			}
			// ensure it is a pure identifier
			if((boolean)d.getAttribute("Pointer")==true||(int)d.getAttribute("Array Size")>0)
			{
				a.goodNodeComeBad("Unmatched Type");
				return;
			}
			add(a,new DebugBytecode(Kinds.debugBytecodeGetAddress,(String)a.getContents()));
		}
		else
			System.out.println("Unit Error");;
	}
	
	private void AExpression(ANode a)
	{
		ANode c1 = a.getChildAt(0);
		ANode c2 = a.getChildAt(1);
		
		AExpression(c1);
		AExpression(c2);
		
		//test the type
		
		// first, if the code is bad, we assume it is good
		// just check the type and not other checking? - no, the left to be runtime error
		
		if(isBad(c1)&&isBad(c2))
		{
			//look for the c2 for information, if both bad them this node is bad
			c1.addAttribute("Data Type", getDataType(c2));
		}
		else if((!isBad(c1)&&isBad(c2)))
		{
			c2.addAttribute("Data Type", getDataType(c1));
		}
		else if(isBad(c1)&&isBad(c2))
		{
			a.goodNodeComeBad("Still Bad");
			return;
		}
		
		String dataType = getDataType(c1);
		
		if(dataType.equals("int")) {
			if(a.getTag().equals("add"))
			{				
				add(a,new DebugBytecode(Kinds.iadd));
			}
			else if(a.getTag().equals("sub"))
			{
				add(a,new DebugBytecode(Kinds.isub));
			}
			else if(a.getTag().equals("mul"))
			{
				add(a,new DebugBytecode(Kinds.imul));
			}
			else if(a.getTag().equals("div"))
			{
				add(a,new DebugBytecode(Kinds.idiv));
			}
			else
			{
				System.out.println("in AExpression Error");
			}
		}
		else if(dataType.equals("real"))
		{
			if(a.getTag().equals("add"))
			{				
				add(a,new DebugBytecode(Kinds.fadd));
			}
			else if(a.getTag().equals("sub"))
			{
				add(a,new DebugBytecode(Kinds.fsub));
			}
			else if(a.getTag().equals("mul"))
			{
				add(a,new DebugBytecode(Kinds.fmul));
			}
			else if(a.getTag().equals("div"))
			{
				add(a,new DebugBytecode(Kinds.fdiv));
			}
			else
			{
				System.out.println("in AExpression Error");
			}
		}
		else
		{
			System.out.println("in AExpression Error");
		}
		
	}
	
	
	
	/**
	 * @param a, knowing which node we put code to
	 * @param dbc
	 */
	private void add(ANode a,DebugBytecode dbc)
	{
		out.pushCode(a.getLineNo(), dbc);
	}
	
	private String getAttribute(String symbol, String attribute)
	{
		ANode a =  getVariable(symbol);
		if(a != null)
		{
			return (String) a.getAttribute(attribute);
		}
		return null;
	}
	
	/**
	 * @param symbol
	 * @param attribute
	 * use to change the variable in the environment's attribute, maybe useless
	 */
	private void setAttribute(String symbol, String attribute, Object value)
	{
		ANode a =  getVariable(symbol);
		if(a != null)
		{
			a.addAttribute(attribute, value);
		}
	}
	
	private void AReadAndWrite(ANode a)
	{
		
	}
	
	private void AIfElse(ANode a)
	{
		
	}
	
	private void AWhile(ANode a)
	{
		
	}
	
	private void Axxx(ANode a)
	{
		
	}
	
	/**
	 * @param symbol
	 * @return Data Type of that symbol
	 */
	private String getDataType(String symbol)
	{
		return getAttribute(symbol, "Data Type");
	}
	
	/**
	 * @param a
	 * @return Data Type of a
	 */
	private String getDataType(ANode a)
	{
		return (String)a.getAttribute("Data Type");
	}
	
	/**
	 * @param a
	 * @param type
	 */
	private void addDataType(ANode a ,String type)
	{
		a.addAttribute("Data Type", type);
	}
	
	private boolean isBad(ANode a)
	{
		return a.getTag().equals("Bad Node");
	}
	
	private String getSymbolFromLeftValue(ANode a)
	{
		ArrayList<Object> contents = (ArrayList<Object>) a.getContents();
		String symbol = (String) contents.get(1);
		return symbol;
	}
	
	
}
